// -------------------------------------------------------------
//
// Module: HB_32
//
// Generated by MATLAB(R) 7.2 and the Filter Design HDL Coder 1.4.
//
// Generated on: 2007-02-08 14:13:48
//
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetLanguage: Verilog
// Name: HB_32
// TargetDirectory: C:\Data\QS\QuickSilver\trunk\QS1R_AB_QUARTUS\CIC
// OptimizeForHDL: On
// SerialPartition: -1
// InlineConfigurations: Off
// SafeZeroConcat: Off
// TestBenchStimulus: step ramp chirp noise 
//
// Filter Settings:
//
// Discrete-Time FIR Multirate Filter (real)
// -----------------------------------------
// Filter Structure   : Direct-Form FIR Polyphase Decimator
// Decimation Factor  : 32
// Polyphase Length   : 1
// Filter Length      : 15
// Stable             : Yes
// Linear Phase       : Yes (Type 1)
//
// Arithmetic         : fixed
// Numerator          : s16,15 -> [-1 1)
// Input              : s32,15 -> [-65536 65536)
// Filter Internals   : Full Precision
//   Output           : s48,30 -> [-131072 131072)  (auto determined)
//   Product          : s46,30 -> [-32768 32768)  (auto determined)
//   Accumulator      : s48,30 -> [-131072 131072)  (auto determined)
//   Round Mode       : No rounding
//   Overflow Mode    : No overflow
//
// Implementation Cost
// Number of Multipliers : 9
// Number of Adders      : 8
// Number of States      : 0
// MultPerInputSample    : 0.28125
// AddPerInputSample     : 0.25
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module HB_32 
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out,
                ce_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   signed [31:0] filter_in; //sfix32_En15
  output  signed [47:0] filter_out; //sfix48_En30
  output  ce_out; 

////////////////////////////////////////////////////////////////
//Module Architecture: HB_32
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter signed [15:0] coeffphase1_1 = 16'b1111111110101111; //sfix16_En15
  parameter signed [15:0] coeffphase2_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase3_1 = 16'b0000001000101100; //sfix16_En15
  parameter signed [15:0] coeffphase4_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase5_1 = 16'b1111011101010110; //sfix16_En15
  parameter signed [15:0] coeffphase6_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase7_1 = 16'b0010011011001110; //sfix16_En15
  parameter signed [15:0] coeffphase8_1 = 16'b0100000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase9_1 = 16'b0010011011001110; //sfix16_En15
  parameter signed [15:0] coeffphase10_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase11_1 = 16'b1111011101010110; //sfix16_En15
  parameter signed [15:0] coeffphase12_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase13_1 = 16'b0000001000101100; //sfix16_En15
  parameter signed [15:0] coeffphase14_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase15_1 = 16'b1111111110101111; //sfix16_En15
  parameter signed [15:0] coeffphase16_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase17_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase18_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase19_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase20_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase21_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase22_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase23_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase24_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase25_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase26_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase27_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase28_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase29_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase30_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase31_1 = 16'b0000000000000000; //sfix16_En15
  parameter signed [15:0] coeffphase32_1 = 16'b0000000000000000; //sfix16_En15
  // Signals
  reg  [31:0] ring_count; // ufix32
  wire phase_0; // boolean
  wire phase_1; // boolean
  wire phase_2; // boolean
  wire phase_3; // boolean
  wire phase_4; // boolean
  wire phase_5; // boolean
  wire phase_6; // boolean
  wire phase_7; // boolean
  wire phase_8; // boolean
  wire phase_9; // boolean
  wire phase_10; // boolean
  wire phase_11; // boolean
  wire phase_12; // boolean
  wire phase_13; // boolean
  wire phase_14; // boolean
  wire phase_15; // boolean
  wire phase_16; // boolean
  wire phase_17; // boolean
  wire phase_18; // boolean
  wire phase_19; // boolean
  wire phase_20; // boolean
  wire phase_21; // boolean
  wire phase_22; // boolean
  wire phase_23; // boolean
  wire phase_24; // boolean
  wire phase_25; // boolean
  wire phase_26; // boolean
  wire phase_27; // boolean
  wire phase_28; // boolean
  wire phase_29; // boolean
  wire phase_30; // boolean
  wire phase_31; // boolean
  reg  ce_out_reg; // boolean
  reg  signed [31:0] input_register; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase0; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase2; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase4; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase6; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase7; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase8; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase10; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase12; // sfix32_En15
  reg  signed [31:0] input_pipeline_phase14; // sfix32_En15
  wire signed [45:0] product_phase0_1; // sfix46_En30
  wire signed [47:0] mul_temp; // sfix48_En30
  wire signed [45:0] product_phase2_1; // sfix46_En30
  wire signed [47:0] mul_temp_1; // sfix48_En30
  wire signed [45:0] product_phase4_1; // sfix46_En30
  wire signed [47:0] mul_temp_2; // sfix48_En30
  wire signed [45:0] product_phase6_1; // sfix46_En30
  wire signed [47:0] mul_temp_3; // sfix48_En30
  wire signed [45:0] product_phase7_1; // sfix46_En30
  wire signed [45:0] product_phase8_1; // sfix46_En30
  wire signed [47:0] mul_temp_4; // sfix48_En30
  wire signed [45:0] product_phase10_1; // sfix46_En30
  wire signed [47:0] mul_temp_5; // sfix48_En30
  wire signed [45:0] product_phase12_1; // sfix46_En30
  wire signed [47:0] mul_temp_6; // sfix48_En30
  wire signed [45:0] product_phase14_1; // sfix46_En30
  wire signed [47:0] mul_temp_7; // sfix48_En30
  wire signed [47:0] sum_1; // sfix48_En30
  wire signed [45:0] add_signext; // sfix46_En30
  wire signed [45:0] add_signext_1; // sfix46_En30
  wire signed [46:0] add_temp; // sfix47_En30
  wire signed [47:0] sum_2; // sfix48_En30
  wire signed [47:0] add_signext_2; // sfix48_En30
  wire signed [47:0] add_signext_3; // sfix48_En30
  wire signed [48:0] add_temp_1; // sfix49_En30
  wire signed [47:0] sum_3; // sfix48_En30
  wire signed [47:0] add_signext_4; // sfix48_En30
  wire signed [47:0] add_signext_5; // sfix48_En30
  wire signed [48:0] add_temp_2; // sfix49_En30
  wire signed [47:0] sum_4; // sfix48_En30
  wire signed [47:0] add_signext_6; // sfix48_En30
  wire signed [47:0] add_signext_7; // sfix48_En30
  wire signed [48:0] add_temp_3; // sfix49_En30
  wire signed [47:0] sum_5; // sfix48_En30
  wire signed [47:0] add_signext_8; // sfix48_En30
  wire signed [47:0] add_signext_9; // sfix48_En30
  wire signed [48:0] add_temp_4; // sfix49_En30
  wire signed [47:0] sum_6; // sfix48_En30
  wire signed [47:0] add_signext_10; // sfix48_En30
  wire signed [47:0] add_signext_11; // sfix48_En30
  wire signed [48:0] add_temp_5; // sfix49_En30
  wire signed [47:0] sum_7; // sfix48_En30
  wire signed [47:0] add_signext_12; // sfix48_En30
  wire signed [47:0] add_signext_13; // sfix48_En30
  wire signed [48:0] add_temp_6; // sfix49_En30
  wire signed [47:0] sum_8; // sfix48_En30
  wire signed [47:0] add_signext_14; // sfix48_En30
  wire signed [47:0] add_signext_15; // sfix48_En30
  wire signed [48:0] add_temp_7; // sfix49_En30
  reg  signed [47:0] output_register; // sfix48_En30

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: ce_output
      if (reset == 1'b1) begin
        ring_count <= 1;
      end
      else begin
        if (clk_enable == 1'b1) begin
          ring_count <= {ring_count[0], ring_count[31 : 1]};
        end
      end
    end // ce_output

  assign  phase_0 = ring_count[0]  && clk_enable;

  assign  phase_1 = ring_count[1]  && clk_enable;

  assign  phase_2 = ring_count[2]  && clk_enable;

  assign  phase_3 = ring_count[3]  && clk_enable;

  assign  phase_4 = ring_count[4]  && clk_enable;

  assign  phase_5 = ring_count[5]  && clk_enable;

  assign  phase_6 = ring_count[6]  && clk_enable;

  assign  phase_7 = ring_count[7]  && clk_enable;

  assign  phase_8 = ring_count[8]  && clk_enable;

  assign  phase_9 = ring_count[9]  && clk_enable;

  assign  phase_10 = ring_count[10]  && clk_enable;

  assign  phase_11 = ring_count[11]  && clk_enable;

  assign  phase_12 = ring_count[12]  && clk_enable;

  assign  phase_13 = ring_count[13]  && clk_enable;

  assign  phase_14 = ring_count[14]  && clk_enable;

  assign  phase_15 = ring_count[15]  && clk_enable;

  assign  phase_16 = ring_count[16]  && clk_enable;

  assign  phase_17 = ring_count[17]  && clk_enable;

  assign  phase_18 = ring_count[18]  && clk_enable;

  assign  phase_19 = ring_count[19]  && clk_enable;

  assign  phase_20 = ring_count[20]  && clk_enable;

  assign  phase_21 = ring_count[21]  && clk_enable;

  assign  phase_22 = ring_count[22]  && clk_enable;

  assign  phase_23 = ring_count[23]  && clk_enable;

  assign  phase_24 = ring_count[24]  && clk_enable;

  assign  phase_25 = ring_count[25]  && clk_enable;

  assign  phase_26 = ring_count[26]  && clk_enable;

  assign  phase_27 = ring_count[27]  && clk_enable;

  assign  phase_28 = ring_count[28]  && clk_enable;

  assign  phase_29 = ring_count[29]  && clk_enable;

  assign  phase_30 = ring_count[30]  && clk_enable;

  assign  phase_31 = ring_count[31]  && clk_enable;

  //   ------------------ CE Output Generation ------------------

  //   ------------------ CE Output Register ------------------

  always @ (posedge clk or posedge reset)
    begin: ce_output_register
      if (reset == 1'b1) begin
        ce_out_reg <= 1'b0;
      end
      else begin
          ce_out_reg <= phase_31;
      end
    end // ce_output_register

  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= filter_in;
        end
      end
    end // input_reg_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase0_process
      if (reset == 1'b1) begin
        input_pipeline_phase0 <= 0;
      end
      else begin
        if (phase_31 == 1'b1) begin
          input_pipeline_phase0 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase0_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase2_process
      if (reset == 1'b1) begin
        input_pipeline_phase2 <= 0;
      end
      else begin
        if (phase_1 == 1'b1) begin
          input_pipeline_phase2 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase2_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase4_process
      if (reset == 1'b1) begin
        input_pipeline_phase4 <= 0;
      end
      else begin
        if (phase_3 == 1'b1) begin
          input_pipeline_phase4 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase4_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase6_process
      if (reset == 1'b1) begin
        input_pipeline_phase6 <= 0;
      end
      else begin
        if (phase_5 == 1'b1) begin
          input_pipeline_phase6 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase6_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase7_process
      if (reset == 1'b1) begin
        input_pipeline_phase7 <= 0;
      end
      else begin
        if (phase_6 == 1'b1) begin
          input_pipeline_phase7 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase7_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase8_process
      if (reset == 1'b1) begin
        input_pipeline_phase8 <= 0;
      end
      else begin
        if (phase_7 == 1'b1) begin
          input_pipeline_phase8 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase8_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase10_process
      if (reset == 1'b1) begin
        input_pipeline_phase10 <= 0;
      end
      else begin
        if (phase_9 == 1'b1) begin
          input_pipeline_phase10 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase10_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase12_process
      if (reset == 1'b1) begin
        input_pipeline_phase12 <= 0;
      end
      else begin
        if (phase_11 == 1'b1) begin
          input_pipeline_phase12 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase12_process

  always @ (posedge clk or posedge reset)
    begin: Delay_Pipeline_Phase14_process
      if (reset == 1'b1) begin
        input_pipeline_phase14 <= 0;
      end
      else begin
        if (phase_13 == 1'b1) begin
          input_pipeline_phase14 <= input_register;
        end
      end
    end // Delay_Pipeline_Phase14_process

  assign mul_temp = input_register * coeffphase1_1;
  assign product_phase0_1 = mul_temp[45:0];

  assign mul_temp_1 = input_pipeline_phase2 * coeffphase3_1;
  assign product_phase2_1 = mul_temp_1[45:0];

  assign mul_temp_2 = input_pipeline_phase4 * coeffphase5_1;
  assign product_phase4_1 = mul_temp_2[45:0];

  assign mul_temp_3 = input_pipeline_phase6 * coeffphase7_1;
  assign product_phase6_1 = mul_temp_3[45:0];

  assign product_phase7_1 = $signed({input_pipeline_phase7[31:0], 14'b00000000000000});

  assign mul_temp_4 = input_pipeline_phase8 * coeffphase9_1;
  assign product_phase8_1 = mul_temp_4[45:0];

  assign mul_temp_5 = input_pipeline_phase10 * coeffphase11_1;
  assign product_phase10_1 = mul_temp_5[45:0];

  assign mul_temp_6 = input_pipeline_phase12 * coeffphase13_1;
  assign product_phase12_1 = mul_temp_6[45:0];

  assign mul_temp_7 = input_pipeline_phase14 * coeffphase15_1;
  assign product_phase14_1 = mul_temp_7[45:0];

  assign add_signext = product_phase14_1;
  assign add_signext_1 = product_phase12_1;
  assign add_temp = add_signext + add_signext_1;
  assign sum_1 = $signed({{1{add_temp[46]}}, add_temp});

  assign add_signext_2 = sum_1;
  assign add_signext_3 = $signed({{2{product_phase10_1[45]}}, product_phase10_1});
  assign add_temp_1 = add_signext_2 + add_signext_3;
  assign sum_2 = add_temp_1[47:0];

  assign add_signext_4 = sum_2;
  assign add_signext_5 = $signed({{2{product_phase8_1[45]}}, product_phase8_1});
  assign add_temp_2 = add_signext_4 + add_signext_5;
  assign sum_3 = add_temp_2[47:0];

  assign add_signext_6 = sum_3;
  assign add_signext_7 = $signed({{2{product_phase7_1[45]}}, product_phase7_1});
  assign add_temp_3 = add_signext_6 + add_signext_7;
  assign sum_4 = add_temp_3[47:0];

  assign add_signext_8 = sum_4;
  assign add_signext_9 = $signed({{2{product_phase6_1[45]}}, product_phase6_1});
  assign add_temp_4 = add_signext_8 + add_signext_9;
  assign sum_5 = add_temp_4[47:0];

  assign add_signext_10 = sum_5;
  assign add_signext_11 = $signed({{2{product_phase4_1[45]}}, product_phase4_1});
  assign add_temp_5 = add_signext_10 + add_signext_11;
  assign sum_6 = add_temp_5[47:0];

  assign add_signext_12 = sum_6;
  assign add_signext_13 = $signed({{2{product_phase2_1[45]}}, product_phase2_1});
  assign add_temp_6 = add_signext_12 + add_signext_13;
  assign sum_7 = add_temp_6[47:0];

  assign add_signext_14 = sum_7;
  assign add_signext_15 = $signed({{2{product_phase0_1[45]}}, product_phase0_1});
  assign add_temp_7 = add_signext_14 + add_signext_15;
  assign sum_8 = add_temp_7[47:0];

  always @ (posedge clk or posedge reset)
    begin: output_register_process
      if (reset == 1'b1) begin
        output_register <= 0;
      end
      else begin
        if (phase_31 == 1'b1) begin
          output_register <= sum_8;
        end
      end
    end // output_register_process

  // Assignment Statements
  assign ce_out = ce_out_reg;
  assign filter_out = output_register;
endmodule  // HB_32
