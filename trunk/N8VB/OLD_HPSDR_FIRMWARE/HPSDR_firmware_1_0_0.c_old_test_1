/*
; * Copyright (c) 2005 Philip A Covington, N8VB
; *
; * This program is free software; you can redistribute it and/or modify
; * it under the terms of the GNU General Public License as published by
; * the Free Software Foundation; either version 2 of the License, or
; * (at your option) any later version.
; *
; * This program is distributed in the hope that it will be useful,
; * but WITHOUT ANY WARRANTY; without even the implied warranty of
; * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
; * GNU General Public License for more details.
; *
; * You should have received a copy of the GNU General Public License
; * along with this program; if not, write to the Free Software
; * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
; *
; */

#define ALLOCATE_EXTERN // Allocate explicit register addresses here

#include "hpsdr.h"
#include "fx2regs.h"
#include "fx2sdly.h"
#include "fx2_n8vb.h"

void init_fx2 (void)
{
	CPUCS = bmCLKSPD1; // CPU runs @ 48 MHz

	SYNCDELAY;
	REVCTL = 0x03; // TRM recommends setting bit 0 and bit 1 
	SYNCDELAY;

	FX2_SPDAUTO_ENABLE();	// setup autopointer enabled

	EP1OUTCS &= ~bmEPSTALL; //reset stall bit on EP1 OUT 
	EP1OUTBC = 0x40;	//re-arm for EP1 out transfer

	EP1INCS &= ~bmEPSTALL;

	IFCONFIG=0xC0;
	PORTACFG=0x00;
	PORTECFG=0x00;

	OEA=0x03;
	IOA=0x03;

	OEE=0x02;
	IOE=0x02;

	return;
}

/*------------------------------------------------
MAIN C Function
------------------------------------------------*/

void main (void)
{
	void   *dscr_ptr;
	WORD xdata  *wdscr_ptr;
	BYTE xdata	*bdscr_ptr;
    
	wascalled = FALSE;
	got_vend_cmd = FALSE;
	washere = FALSE;

	sptrhigh = 0;
	sptrlow = 0;

    time1_L = 0x20;
	time1_H = 0;
	time2_L = 0x20;
	time2_H = 0;

	old_time1_L = 0;
	old_time1_H = 0;
	old_time2_L = 0;
	old_time2_H = 0;

	test_extern_mem1 = 0xAA;
	test_extern_mem2 = 0xCC;

	init_fx2();
    
	pDeviceDscr = (WORD)&DeviceDscr;
	pDeviceQualDscr = (WORD)&DeviceQualDscr;
	pHighSpeedConfigDscr = (WORD)&HighSpeedConfigDscr;
	pFullSpeedConfigDscr = (WORD)&FullSpeedConfigDscr;
	pStringDscr = (WORD)&StringDscr0;
	pConfigDscr = pHighSpeedConfigDscr;
    pOtherConfigDscr = pFullSpeedConfigDscr;
    
	RxSUD = FALSE;
    
	FX2_USB_INT_ENABLE();  //enable USB interrupts

	FX2_INT2_AV_ENABLE();

	FX2_USB_INT_MASK(bmSUDAV | bmSUTOK | bmHSGRANT);
	
	FX2_8051_INT_ENABLE();
	
	if(FX2_NEED_TO_RENUM())
	{
		FX2_Discon(TRUE);   // renumerate
	}

	FX2_USB_CONNECT();

	//SYNCDELAY;
	//FX2_USB_SET_RENUM();  // set renum bit to use defined interface, not default
	//SYNCDELAY;

	CKCO = 0x02;  // 2 cycle moves

	IOA = 0x02;
	IOE = 0x02;

	while (TRUE)
	{
		if(RxSUD)            // test for SUDAV
		{
			FX2_SPDAUTO_ENABLE();
			IOA = 0x03;
			SetupCommand();          // Implement setup command
			RxSUD = FALSE;          // Clear SUDAV flag
			IOA = 0x02;
		}

		if (!(EP1OUTCS & bmEPBUSY))  //check for data available in EP1 out
		{
			if (!(EP1INCS & bmEPBUSY)) // can we send on EP1 ?
			{
				if (EP1OUTBUF[0] == 1) // Get string descriptor
				{
					if(dscr_ptr = (void *)FX2_GetStringDscr(EP1OUTBUF[1]))
					{
						wdscr_ptr = (WORD xdata *)dscr_ptr;
						bdscr_ptr = (BYTE xdata *)dscr_ptr;
						EP1INBUF[0] = MSB(wdscr_ptr);
						EP1INBUF[1] = LSB(wdscr_ptr);
						EP1INBUF[2] = *bdscr_ptr++;
						EP1INBUF[3] = *bdscr_ptr++;
						EP1INBUF[4] = *bdscr_ptr++;
						EP1INBUF[5] = *bdscr_ptr++;
						EP1INBUF[6] = *bdscr_ptr++;
						EP1INBUF[7] = *bdscr_ptr++;
						EP1INBUF[8] = (BYTE)wascalled;
						EP1INCS &= ~bmEPSTALL;
						EP1INBC = 0x09; // 9 bytes to transfer, initates send on EP1 IN
					}
					else // error
					{
						EP1INBUF[0] = 0xFF;
						EP1INBUF[1] = 0xFF;
						EP1INCS &= ~bmEPSTALL;
						EP1INBC = 0x02; // 2 bytes to transfer, initates send on EP1 IN
					}
				}
				else if (EP1OUTBUF[0] == 2)
				{
					EP1INBUF[0] = MSB(pDeviceDscr);
					EP1INBUF[1] = LSB(pDeviceDscr);
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 0x02; // 2 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 3)
				{
					EP1INBUF[0] = MSB(pDeviceQualDscr);
					EP1INBUF[1] = LSB(pDeviceQualDscr);
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 0x02; // 2 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 4)
				{
					EP1INBUF[0] = MSB(pHighSpeedConfigDscr);
					EP1INBUF[1] = LSB(pHighSpeedConfigDscr);
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 0x02; // 2 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 5)
				{
					wascalled = (BOOL)EP1OUTBUF[1];
				}
				else if (EP1OUTBUF[0] == 6)
				{
					EP1INBUF[0] = (BYTE)wascalled;
					EP1INBUF[1] = (BYTE)got_vend_cmd;
					EP1INBUF[2] = (BYTE)washere;
					EP1INBUF[3] = sptrhigh;
					EP1INBUF[4] = sptrlow;
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 0x05; // 5 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 7)
				{
					EP1INBUF[0] = (BYTE)setup0;
					EP1INBUF[1] = (BYTE)setup1;
					EP1INBUF[2] = (BYTE)setup2;
					EP1INBUF[3] = (BYTE)setup3;
					EP1INBUF[4] = (BYTE)setup4;
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 0x05; // 5 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 8)
				{
					EP1INBUF[0] = (BYTE)time1_L;
					EP1INBUF[1] = (BYTE)time1_H;
					EP1INBUF[2] = (BYTE)time2_L;
					EP1INBUF[3] = (BYTE)time2_H;
					EP1INBUF[4] = (BYTE)RxSUD;
					EP1INBUF[5] = (BYTE)RWUEN;
					EP1INBUF[6] = (BYTE)SELFPWR;
					EP1INBUF[7] = (BYTE)Configuration;
					EP1INBUF[8] = (BYTE)AlternateSetting;
					EP1INBUF[9] = MSB(pDeviceDscr);
					EP1INBUF[10] = LSB(pDeviceDscr);
					EP1INBUF[11] = MSB(pDeviceQualDscr);
					EP1INBUF[12] = LSB(pDeviceQualDscr);
					EP1INBUF[13] = MSB(pHighSpeedConfigDscr);
					EP1INBUF[14] = LSB(pHighSpeedConfigDscr);
					EP1INBUF[15] = MSB(pFullSpeedConfigDscr);
					EP1INBUF[16] = LSB(pFullSpeedConfigDscr);
					EP1INBUF[17] = MSB(pConfigDscr);
					EP1INBUF[18] = LSB(pConfigDscr);
					EP1INBUF[19] = MSB(pOtherConfigDscr);
					EP1INBUF[20] = LSB(pOtherConfigDscr);
					EP1INBUF[21] = MSB(pStringDscr);
					EP1INBUF[22] = LSB(pStringDscr);
					EP1INCS &= ~bmEPSTALL;
					EP1INBC = 23; // 23 bytes to transfer, initates send on EP1 IN
				}
				else if (EP1OUTBUF[0] == 9)
				{
					if (EP1OUTBUF[1] == 1)
					{
						EP1INBUF[0] = (BYTE)test_extern_mem1;
						EP1INBUF[1] = (BYTE)test_extern_mem2;
						EP1INCS &= ~bmEPSTALL;
						EP1INBC = 0x02; // 2 bytes to transfer, initates send on EP1 IN
					}
					else if (EP1OUTBUF[1] == 2)
					{
						test_extern_mem1 = (BYTE)EP1INBUF[2];
						test_extern_mem2 = (BYTE)EP1INBUF[3];
					}
				}
			}
			else
			{
				if (EP1OUTBUF[0] == 5)
				{
					wascalled = (BOOL)EP1OUTBUF[1];
				}
			}

			EP1OUTCS &= ~bmEPSTALL; //reset stall bit on EP1 OUT
			EP1OUTBC = 0x40;	//re-arm for EP1 out transfer
		}
	}
}

// Setup Command (EP0) request parser
void SetupCommand(void)
{
   void   *dscr_ptr;
   wascalled = TRUE;

   setup0 = SETUPDAT[0];
   setup1 = SETUPDAT[1];
   setup2 = SETUPDAT[2];
   setup3 = SETUPDAT[3];
   setup4 = SETUPDAT[4];

   switch(SETUPDAT[1])
   {
      case SC_GET_DESCRIPTOR:                  // *** Get Descriptor
         if(DR_GetDescriptor())
            switch(SETUPDAT[3])         
            {
               case GD_DEVICE:            // Device
                  SUDPTRH = MSB(pDeviceDscr);
                  SUDPTRL = LSB(pDeviceDscr);
                  break;
               case GD_DEVICE_QUALIFIER:            // Device Qualifier
                  SUDPTRH = MSB(pDeviceQualDscr);
                  SUDPTRL = LSB(pDeviceQualDscr);
                  break;
               case GD_CONFIGURATION:         // Configuration
                  SUDPTRH = MSB(pConfigDscr);
                  SUDPTRL = LSB(pConfigDscr);
                  break;
               case GD_OTHER_SPEED_CONFIGURATION:  // Other Speed Configuration
                  SUDPTRH = MSB(pOtherConfigDscr);
                  SUDPTRL = LSB(pOtherConfigDscr);
                  break;
               case GD_STRING:            // String
                  if(dscr_ptr = (void *)FX2_GetStringDscr(SETUPDAT[2]))
                  {
					 washere = TRUE;
					 sptrhigh = MSB(dscr_ptr);
					 sptrlow = LSB(dscr_ptr);
                     SUDPTRH = MSB(dscr_ptr);
                     SUDPTRL = LSB(dscr_ptr);
                  }
                  else 
                     FX2_STALL_EP0();   // Stall End Point 0
                  break;
               default:            // Invalid request
                  FX2_STALL_EP0();      // Stall End Point 0
            }
         break;
      case SC_GET_INTERFACE:                  // *** Get Interface
         DR_GetInterface();
         break;
      case SC_SET_INTERFACE:                  // *** Set Interface
         DR_SetInterface();
         break;
      case SC_SET_CONFIGURATION:               // *** Set Configuration
         DR_SetConfiguration();
         break;
      case SC_GET_CONFIGURATION:               // *** Get Configuration
         DR_GetConfiguration();
         break;
      case SC_GET_STATUS:                  // *** Get Status
         if(DR_GetStatus())
            switch(SETUPDAT[0])
            {
               case GS_DEVICE:            // Device
                  EP0BUF[0] = ((BYTE)RWUEN << 1) | (BYTE)SELFPWR;
                  EP0BUF[1] = 0;
                  EP0BCH = 0;
                  EP0BCL = 2;
                  break;
               case GS_INTERFACE:         // Interface
                  EP0BUF[0] = 0;
                  EP0BUF[1] = 0;
                  EP0BCH = 0;
                  EP0BCL = 2;
                  break;
               case GS_ENDPOINT:         // End Point
                  EP0BUF[0] = *(BYTE xdata *) epcs(SETUPDAT[4]) & bmEPSTALL;
                  EP0BUF[1] = 0;
                  EP0BCH = 0;
                  EP0BCL = 2;
                  break;
               default:            // Invalid Command
                  FX2_STALL_EP0();      // Stall End Point 0
            }
         break;
      case SC_CLEAR_FEATURE:                  // *** Clear Feature
         if(DR_ClearFeature())
            switch(SETUPDAT[0])
            {
               case FT_DEVICE:            // Device
                  if(SETUPDAT[2] == 1)
                     RWUEN = FALSE;       // Disable Remote Wakeup
                  else
                     FX2_STALL_EP0();   // Stall End Point 0
                  break;
               case FT_ENDPOINT:         // End Point
                  if(SETUPDAT[2] == 0)
                  {
                     *(BYTE xdata *) epcs(SETUPDAT[4]) &= ~bmEPSTALL;
                     FX2_RESET_DATA_TOGGLE( SETUPDAT[4] );
                  }
                  else
                     FX2_STALL_EP0();   // Stall End Point 0
                  break;
            }
         break;
      case SC_SET_FEATURE:                  // *** Set Feature
         if(DR_SetFeature())
            switch(SETUPDAT[0])
            {
               case FT_DEVICE:            // Device
                  if(SETUPDAT[2] == 1)
                     RWUEN = TRUE;      // Enable Remote Wakeup
                  else if(SETUPDAT[2] == 2)
                     // Set Feature Test Mode.  The core handles this request.  However, it is
                     // necessary for the firmware to complete the handshake phase of the
                     // control transfer before the chip will enter test mode.  It is also
                     // necessary for FX2 to be physically disconnected (D+ and D-)
                     // from the host before it will enter test mode.
                     break;
                  else
                     FX2_STALL_EP0();   // Stall End Point 0
                  break;
               case FT_ENDPOINT:         // End Point
                  *(BYTE xdata *) epcs(SETUPDAT[4]) |= bmEPSTALL;
                  break;
            }
         break;
      default:                     // *** Invalid Command
         if(DR_VendorCmnd())
            FX2_STALL_EP0();            // Stall End Point 0
   }

   // Acknowledge handshake phase of device request
   EP0CS |= bmHSNAK;
}

//-----------------------------------------------------------------------------
// Device Request hooks
//   The following hooks are called by the end point 0 device request parser.
//-----------------------------------------------------------------------------

BOOL DR_GetDescriptor(void)
{
   return(TRUE);
}

BOOL DR_SetConfiguration(void)   // Called when a Set Configuration command is received
{
   Configuration = SETUPDAT[2];
   return(TRUE);            // Handled by user code
}

BOOL DR_GetConfiguration(void)   // Called when a Get Configuration command is received
{
   EP0BUF[0] = Configuration;
   EP0BCH = 0;
   EP0BCL = 1;
   return(TRUE);            // Handled by user code
}

BOOL DR_SetInterface(void)       // Called when a Set Interface command is received
{
   AlternateSetting = SETUPDAT[2];
   return(TRUE);            // Handled by user code
}

BOOL DR_GetInterface(void)       // Called when a Set Interface command is received
{
	EP0BUF[0] = AlternateSetting;
	EP0BCH = 0;
	EP0BCL = 1;
	return(TRUE);            // Handled by user code
}

BOOL DR_GetStatus(void)
{
	return(TRUE);
}

BOOL DR_ClearFeature(void)
{
	return(TRUE);
}

BOOL DR_SetFeature(void)
{
	return(TRUE);
}

BOOL DR_VendorCmnd(void)
{
	got_vend_cmd = TRUE;
	return(TRUE);
}

//-----------------------------------------------------------------------------
// USB Interrupt Handlers
//   The following functions are called by the USB interrupt jump table.
//-----------------------------------------------------------------------------

// Setup Data Available interrupt Handler
void ISR_Sudav(void) interrupt  
{
   RxSUD = TRUE;            // Set flag
   FX2_IRQ_CLEAR();
   FX2_CLEAR_USB_IRQ(bmSUDAV);	// Clear SUDAV IRQ
}

// Setup Token interrupt Handler
void ISR_Sutok(void) interrupt  
{
   FX2_IRQ_CLEAR();
   FX2_CLEAR_USB_IRQ(bmSUTOK);	// Clear SUTOK IRQ
}

void ISR_Sof(void) interrupt  
{
   FX2_IRQ_CLEAR();
   FX2_CLEAR_USB_IRQ(bmSOF);	// Clear SOF IRQ
}

void ISR_Usb_Reset(void) interrupt  
{
   // whenever we get a USB reset, we should revert to full speed mode
   pConfigDscr = pFullSpeedConfigDscr;
   pOtherConfigDscr = pHighSpeedConfigDscr;
   
   FX2_IRQ_CLEAR();
   FX2_CLEAR_USB_IRQ(bmURES);	// Clear URES IRQ
}

void ISR_Highspeed(void) interrupt  
{
   if (FX2_HIGHSPEED())
   {
      pConfigDscr = pHighSpeedConfigDscr;
      pOtherConfigDscr = pFullSpeedConfigDscr;
   }

   FX2_IRQ_CLEAR();
   FX2_CLEAR_USB_IRQ(bmHSGRANT);	// Clear HSGrant IRQ
}


