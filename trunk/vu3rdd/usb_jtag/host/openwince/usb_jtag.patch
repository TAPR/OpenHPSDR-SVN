Index: include/cable.h
===================================================================
--- include/cable.h	(.../vendor/openwince)	(Revision 135)
+++ include/cable.h	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -45,6 +45,7 @@
 	void (*done)( cable_t * );
 	void (*clock)( cable_t *, int, int );
 	int (*get_tdo)( cable_t * );
+	int (*transfer)( cable_t *, int, char *, char * );
 	int (*set_trst)( cable_t *, int );
 	int (*get_trst)( cable_t * );
 };
@@ -63,6 +64,7 @@
 int cable_get_tdo( cable_t *cable );
 int cable_set_trst( cable_t *cable, int trst );
 int cable_get_trst( cable_t *cable );
+int cable_transfer( cable_t *cable, int len, char *in, char *out );
 
 extern uint32_t frequency;
 void cable_wait( void );
Index: src/cmd/cable.c
===================================================================
--- src/cmd/cable.c	(.../vendor/openwince)	(Revision 135)
+++ src/cmd/cable.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -85,15 +85,19 @@
 	printf( _(
 		"Usage: %s PORTADDR CABLE\n"
 		"Usage: %s DEV CABLE\n"
+		"Usage: %s VID:PID:S/N CABLE\n"
 		"Select JTAG cable connected to parallel port.\n"
 		"\n"
 		"PORTADDR   parallel port address (e.g. 0x378)\n"
 		"CABLE      cable type\n"
 		"DEV        ppdev device (e.g. /dev/parport0)\n"
+		"VID        empty or USB vendor ID, hex (e.g. 09FB)\n"
+		"PID        empty or USB product ID, hex (e.g. 6001)\n"
+		"S/N        empty or USB product serial number, ASCII\n"
 		"\n"
 		"List of supported cables:\n"
 		"%-13s No cable connected\n"
-	), "cable parallel", "cable ppdev", "none" );
+	), "cable parallel", "cable ppdev", "cable ftdi", "none" );
 
 	for (i = 0; cable_drivers[i]; i++)
 		printf( _("%-13s %s\n"), cable_drivers[i]->name, _(cable_drivers[i]->description) );
Index: src/tap/tap.c
===================================================================
--- src/tap/tap.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/tap.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -56,11 +56,22 @@
 	/* Capture-DR, Capture-IR, Shift-DR, Shift-IR, Exit2-DR or Exit2-IR state */
 	if (tap_state( chain ) & TAPSTAT_CAPTURE)
 		chain_clock( chain, 0, 0 );	/* save last TDO bit :-) */
-	for (i = 0; i < in->len; i++) {
+
+	i = in->len;
+	if(exit) i--;
+	if(out && out->len < i) i = out->len;
+
+	if(out)
+		cable_transfer( chain->cable, i, in->data, out->data );
+	else
+		cable_transfer( chain->cable, i, in->data, NULL );
+
+	for (; i < in->len; i++) {
 		if (out && (i < out->len))
 			out->data[i] = cable_get_tdo( chain->cable );
 		chain_clock( chain, (exit && ((i + 1) == in->len)) ? 1 : 0, in->data[i] );	/* Shift (& Exit1) */
 	}
+
 	/* Shift-DR, Shift-IR, Exit1-DR or Exit1-IR state */
 	if (exit) {
 		chain_clock( chain, 1, 0 );	/* Update-DR or Update-IR */
Index: src/tap/cable/ea253.c
===================================================================
--- src/tap/cable/ea253.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/ea253.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -105,6 +105,7 @@
 	generic_done,
 	ea253_clock,
 	ea253_get_tdo,
+	generic_transfer,
 	ea253_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/triton.c
===================================================================
--- src/tap/cable/triton.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/triton.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -116,6 +116,7 @@
 	generic_done,
 	triton_clock,
 	triton_get_tdo,
+	generic_transfer,
 	triton_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/byteblaster.c
===================================================================
--- src/tap/cable/byteblaster.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/byteblaster.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -131,6 +131,7 @@
 	generic_done,
 	byteblaster_clock,
 	byteblaster_get_tdo,
+	generic_transfer,
 	byteblaster_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/ei012.c
===================================================================
--- src/tap/cable/ei012.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/ei012.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -107,6 +107,7 @@
 	generic_done,
 	ei012_clock,
 	ei012_get_tdo,
+	generic_transfer,
 	ei012_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/wiggler.c
===================================================================
--- src/tap/cable/wiggler.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/wiggler.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -110,6 +110,7 @@
 	generic_done,
 	wiggler_clock,
 	wiggler_get_tdo,
+    generic_transfer,
 	wiggler_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/arcom.c
===================================================================
--- src/tap/cable/arcom.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/arcom.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -105,6 +105,7 @@
 	generic_done,
 	arcom_clock,
 	arcom_get_tdo,
+	generic_transfer,
 	arcom_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/generic.h
===================================================================
--- src/tap/cable/generic.h	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/generic.h	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -40,6 +40,7 @@
 void generic_disconnect( cable_t *cable );
 void generic_cable_free( cable_t *cable );
 void generic_done( cable_t *cable );
+int generic_transfer( cable_t *cable, int len, char *in, char *out );
 int generic_get_trst( cable_t *cable );
 
 #endif /* GENERIC_H */
Index: src/tap/cable/mpcbdm.c
===================================================================
--- src/tap/cable/mpcbdm.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/mpcbdm.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -111,6 +111,7 @@
 	generic_done,
 	mpcbdm_clock,
 	mpcbdm_get_tdo,
+	generic_transfer,
 	mpcbdm_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/keithkoep.c
===================================================================
--- src/tap/cable/keithkoep.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/keithkoep.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -114,6 +114,7 @@
 	generic_done,
 	keithkoep_clock,
 	keithkoep_get_tdo,
+	generic_transfer,
 	keithkoep_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/lattice.c
===================================================================
--- src/tap/cable/lattice.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/lattice.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -97,6 +97,7 @@
 	generic_done,
 	lattice_clock,
 	lattice_get_tdo,
+	generic_transfer,
 	lattice_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/usbblaster.c
===================================================================
--- src/tap/cable/usbblaster.c	(.../vendor/openwince)	(Revision 0)
+++ src/tap/cable/usbblaster.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -0,0 +1,175 @@
+/*
+ * $Id: usbblaster.c,v 1.8 2003/08/22 22:42:02 telka Exp $
+ *
+ * Altera USB-Blaster<tm> Cable Driver
+ * Copyright (C) 2006 K. Waschk
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by Kolja Waschk, 2006; http://www.ixo.de
+ *
+ */
+
+#include "sysdep.h"
+
+#include "cable.h"
+#include "parport.h"
+#include "chain.h"
+
+#include "generic.h"
+
+#define TCK    0
+#define TMS    1
+#define TDI    4
+#define READ   6
+#define SHMODE 7
+#define OTHERS ((1<<2)|(1<<3)|(1<<5))
+
+#define TDO    0
+
+static int
+usbblaster_init( cable_t *cable )
+{
+	int i;
+
+	if (parport_open( cable->port ))
+		return -1;
+
+	for(i=0;i<64;i++)
+		parport_set_data( cable->port, 0 );
+
+	parport_set_control( cable->port, 1 ); // flush
+	parport_set_control( cable->port, 0 ); // noflush
+
+	return 0;
+}
+
+static void
+usbblaster_clock( cable_t *cable, int tms, int tdi )
+{
+	tms = tms ? 1 : 0;
+	tdi = tdi ? 1 : 0;
+
+	parport_set_data( cable->port, OTHERS | (0 << TCK) | (tms << TMS) | (tdi << TDI) );
+	parport_set_data( cable->port, OTHERS | (1 << TCK) | (tms << TMS) | (tdi << TDI) );
+	parport_set_control( cable->port, 1 ); // flush
+	parport_set_control( cable->port, 0 ); // noflush
+}
+
+static int
+usbblaster_get_tdo( cable_t *cable )
+{
+	parport_set_control( cable->port, 0 ); // noflush
+	parport_set_data( cable->port, OTHERS ); /* TCK low */
+	parport_set_data( cable->port, OTHERS | (1 << READ) ); /* TCK low */
+	parport_set_control( cable->port, 1 ); // flush
+	parport_set_control( cable->port, 0 ); // noflush
+#if 0
+    {
+	  char x = ( parport_get_data( cable->port ) & (1 << TDO)) ? 1 : 0;
+      printf("GetTDO %d\n", x);
+      return x;
+    }
+#else
+	return ( parport_get_data( cable->port ) & (1 << TDO)) ? 1 : 0;
+#endif
+}
+
+static int
+usbblaster_set_trst( cable_t *cable, int trst )
+{
+	return 1;
+}
+
+static int
+usbblaster_transfer( cable_t *cable, int len, char *in, char *out )
+{
+	int in_offset = 0;
+	int out_offset = 0;
+	parport_set_control( cable->port, 0 );
+	parport_set_data( cable->port, OTHERS ); /* TCK low */
+
+	while(len - in_offset >= 8)
+	{
+		int i;
+		int chunkbytes = ((len-in_offset)>>3);
+		if(chunkbytes > 63) chunkbytes = 63;
+
+		if(out)
+			parport_set_data( cable->port,(1<<SHMODE)|(1<<READ)|chunkbytes);
+		else
+			parport_set_data( cable->port,(1<<SHMODE)|(0<<READ)|chunkbytes);
+
+		for(i=0; i<chunkbytes; i++)
+		{
+			int j;
+			unsigned char b = 0;
+			for(j=1; j<256; j<<=1) if(in[in_offset++]) b |= j;
+			parport_set_data( cable->port, b );
+		};
+
+		if(out) 
+		{
+			parport_set_control( cable->port, 1 ); // flush
+			parport_set_control( cable->port, 0 ); 
+
+			for(i=0; i<chunkbytes; i++)
+			{
+				int j;
+				unsigned char b = parport_get_data( cable->port );
+#if 0
+                printf("read byte: %02X\n", b);
+#endif
+                 
+				for(j=1; j<256; j<<=1) out[out_offset++] = (b & j) ? 1:0;
+			};
+		};
+	};
+
+	while(len > in_offset)
+	{
+		char tdi = in[in_offset++] ? 1 : 0;
+		parport_set_data( cable->port, OTHERS ); /* TCK low */
+		if(out) parport_set_data( cable->port, OTHERS | (1 << READ) | (tdi << TDI)); 
+		parport_set_data( cable->port, OTHERS | (1 << TCK)  | (tdi << TDI));
+	}
+
+	if(out)
+	{
+		parport_set_control( cable->port, 1 ); // flush
+		parport_set_control( cable->port, 0 );
+
+		while(len > out_offset)
+			out[out_offset++] = ( parport_get_data( cable->port ) & (1 << TDO)) ? 1 : 0;
+	}
+
+	return 0;
+}
+
+cable_driver_t usbblaster_cable_driver = {
+	"UsbBlaster",
+	N_("Altera USB-Blaster Cable"),
+	generic_connect,
+	generic_disconnect,
+	generic_cable_free,
+	usbblaster_init,
+	generic_done,
+	usbblaster_clock,
+	usbblaster_get_tdo,
+	usbblaster_transfer,
+	usbblaster_set_trst,
+	generic_get_trst
+};
Index: src/tap/cable/dlc5.c
===================================================================
--- src/tap/cable/dlc5.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/dlc5.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -102,6 +102,7 @@
 	generic_done,
 	dlc5_clock,
 	dlc5_get_tdo,
+	generic_transfer,
 	dlc5_set_trst,
 	generic_get_trst
 };
Index: src/tap/cable/generic.c
===================================================================
--- src/tap/cable/generic.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable/generic.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -71,6 +71,24 @@
 }
 
 int
+generic_transfer( cable_t *cable, int len, char *in, char *out )
+{
+	int i;
+
+	if(out)
+		for(i=0; i<len; i++) {
+			out[i] = cable_get_tdo( cable );
+			cable_clock( cable, 0, in[i] );
+		}
+	else
+		for(i=0; i<len; i++) {
+			cable_clock( cable, 0, in[i] );
+		}
+
+	return i;
+}
+
+int
 generic_get_trst( cable_t *cable )
 {
 	return PARAM_TRST(cable);
Index: src/tap/cable.c
===================================================================
--- src/tap/cable.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/cable.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -33,6 +33,7 @@
 
 extern cable_driver_t arcom_cable_driver;
 extern cable_driver_t byteblaster_cable_driver;
+extern cable_driver_t usbblaster_cable_driver;
 extern cable_driver_t dlc5_cable_driver;
 extern cable_driver_t ea253_cable_driver;
 extern cable_driver_t ei012_cable_driver;
@@ -47,6 +48,7 @@
 cable_driver_t *cable_drivers[] = {
 	&arcom_cable_driver,
 	&byteblaster_cable_driver,
+	&usbblaster_cable_driver,
 	&dlc5_cable_driver,
 	&ea253_cable_driver,
 	&ei012_cable_driver,
@@ -100,6 +102,14 @@
 	return cable->driver->get_trst( cable );
 }
 
+int
+cable_transfer( cable_t *cable, int len,  char *in, char *out )
+{
+	int r;
+	r=cable->driver->transfer( cable, len, in, out );
+	return r;
+}
+
 void
 cable_wait( void )
 {
Index: src/tap/parport/ftdi.c
===================================================================
--- src/tap/parport/ftdi.c	(.../vendor/openwince)	(Revision 0)
+++ src/tap/parport/ftdi.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -0,0 +1,357 @@
+/*
+ * $Id: ftdi.c,v 1.7 2003/08/19 09:05:25 telka Exp $
+ *
+ * libftdi Driver
+ * Copyright (C) 2006 K. Waschk
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
+ * 02111-1307, USA.
+ *
+ * Written by Kolja Waschk, 2006.
+ * Structure taken from ppdev.c, written by Marcel Telka, 2003.
+ *
+ */
+
+#include "sysdep.h"
+
+#ifdef HAVE_LIBFTDI
+
+#include <fcntl.h>
+#include <stropts.h>
+#include <unistd.h>
+#include <linux/ioctl.h>
+
+#include <stdlib.h>
+#include <string.h>
+
+#include <ftdi.h>
+
+#include "parport.h"
+#include "cable.h"
+
+parport_driver_t ftdi_parport_driver;
+
+typedef struct port_node_t port_node_t;
+
+struct port_node_t {
+	parport_t *port;
+	port_node_t *next;
+};
+
+static port_node_t *ports = NULL;		/* devices */
+
+#define OUTBUF_LEN 64 
+
+typedef struct {
+	char *serial;
+	unsigned int vendor_id;
+	unsigned int product_id;
+	char autoflush;
+	struct ftdi_context *fc;
+	unsigned char outcount;
+	unsigned char *outbuf;
+} ftdi_params_t;
+
+static int ftdi_flush_output ( ftdi_params_t *p );
+
+static parport_t *
+ftdi_parport_alloc( const char *vidpid )
+{
+	ftdi_params_t *params = malloc( sizeof *params );
+	parport_t *parport = malloc( sizeof *parport );
+	port_node_t *node = malloc( sizeof *node );
+	struct ftdi_context *fc = malloc( sizeof(struct ftdi_context) );
+	unsigned char *outbuf = malloc( OUTBUF_LEN );
+
+	if (!node || !parport || !params || !fc || !outbuf)  {
+		free( node );
+		free( parport );
+		free( params );
+		free( fc );
+		return NULL;
+	}
+
+	ftdi_init(fc);
+	params->outbuf = outbuf;
+	params->outcount = 0;
+	params->autoflush = 0;
+	params->product_id = 0;
+	params->vendor_id = 0;
+	params->serial = NULL;
+	params->fc = fc;
+
+	{
+		char *f = strchr(vidpid, ':');
+		char *l = strrchr(vidpid, ':');
+		if(f)
+		{
+			params->vendor_id = strtoul(vidpid, NULL, 16);
+			params->product_id = strtoul(f+1, NULL, 16);
+			if(l!=f) params->serial = strdup(l+1);
+		};
+	};
+
+	parport->params = params;
+	parport->driver = &ftdi_parport_driver;
+	parport->cable = NULL;
+
+	node->port = parport;
+	node->next = ports;
+
+	ports = node;
+
+	return parport;
+}
+
+static void
+ftdi_parport_free( parport_t *port )
+{
+	port_node_t **prev;
+
+	for (prev = &ports; *prev; prev = &((*prev)->next))
+		if ((*prev)->port == port)
+			break;
+
+	if (*prev) {
+		port_node_t *pn = *prev;
+		*prev = pn->next;
+		free( pn );
+	}
+
+	free( ((ftdi_params_t *) port->params)->serial );
+	free( ((ftdi_params_t *) port->params)->outbuf );
+	free( ((ftdi_params_t *) port->params)->fc );
+	free( port->params );
+	free( port );
+}
+
+static cable_t *
+ftdi_connect( const char **par, int parnum )
+{
+	int i;
+	port_node_t *pn;
+	parport_t *parport;
+	cable_t *cable;
+
+	if (parnum != 2) {
+		printf( _("Syntax error!\n") );
+		return NULL;
+	}
+
+	for (pn = ports; pn; pn = pn->next)
+		if (strcmp( pn->port->params, par[0] ) == 0) {
+			printf( _("Disconnecting %s from FTDI device %s\n"), _(pn->port->cable->driver->description), par[0] );
+			pn->port->cable->driver->disconnect( pn->port->cable );
+			break;
+		}
+
+	if (strcmp( par[1], "none" ) == 0) {
+		printf( _("Changed cable to 'none'\n") );
+		return NULL;
+	}
+
+	for (i = 0; cable_drivers[i]; i++)
+		if (strcmp( par[1], cable_drivers[i]->name ) == 0)
+			break;
+
+	if (!cable_drivers[i]) {
+		printf( _("Unknown cable: %s\n"), par[1] );
+		return NULL;
+	}
+
+	printf( _("Initializing %s on FTDI device %s\n"), _(cable_drivers[i]->description), par[0] );
+
+	parport = ftdi_parport_alloc( par[0] );
+	if (!parport) {
+		printf( _("%s(%d) Out of memory.\n"), __FILE__, __LINE__ );
+		return NULL;
+	}
+
+	cable = cable_drivers[i]->connect( cable_drivers[i], parport );
+	if (!cable)
+		ftdi_parport_free( parport );
+
+	return cable;
+}
+
+static int
+ftdi_open( parport_t *parport )
+{
+	int r;
+	ftdi_params_t *p = parport->params;
+	struct ftdi_context *fc = p->fc;
+
+	/* Try to be intelligent about IDs */
+
+	if(p->vendor_id)
+		r = ftdi_usb_open_desc(fc, p->vendor_id, p->product_id, NULL, p->serial);	 /* USB-Blaster */
+	else
+	{
+		r = ftdi_usb_open_desc(fc, 0x09FB, 0x6001, NULL, p->serial);	 /* USB-Blaster */
+		if(r<0) r = ftdi_usb_open_desc(fc, 0x09FB, 0x6002, NULL, p->serial); /* Cubic Cyclonium */
+		if(r<0) r = ftdi_usb_open_desc(fc, 0x09FB, 0x6003, NULL, p->serial); /* NIOS II Evaluation board */
+		if(r<0) r = ftdi_usb_open_desc(fc, 0x16C0, 0x06AD, NULL, p->serial); /* http://www.ixo.de/info/usb_jtag/ */
+	};
+
+	if(r<0)
+	{
+		fprintf (stderr, "Can't open ftdi device: %s\n", 
+						ftdi_get_error_string (fc));
+		ftdi_deinit(fc);
+		return -1;
+	};
+
+	(void)ftdi_disable_bitbang(fc);
+
+	if(ftdi_set_latency_timer(fc, 2)<0)
+	{
+		fprintf (stderr, "Can't set minimum latency: %s\n", 
+						ftdi_get_error_string (fc));
+		ftdi_usb_close(fc);
+		ftdi_deinit(fc);
+		return -1;
+	};
+
+#if 1
+	/* libftdi 0.6 doesn't allow high baudrates, so we send the control
+	   message outselves */
+
+	if (usb_control_msg(fc->usb_dev, 0x40, 3, 1, 0, NULL, 0, fc->usb_write_timeout) != 0)
+	{
+		fprintf (stderr, "Can't set max baud rate.\n");
+		ftdi_usb_close(fc);
+		ftdi_deinit(fc);
+		return -1;
+	};
+#else
+	if(ftdi_set_baudrate(fc, 48000000)<0)
+	{
+	  fprintf (stderr, "Can't set max baud rate: %s\n", 
+						ftdi_get_error_string (fc));
+		ftdi_usb_close(fc);
+		ftdi_deinit(fc);
+		return -1;
+	};
+#endif
+
+	return 0;
+}
+
+static int
+ftdi_flush_output ( ftdi_params_t *p )
+{
+	int xferred;
+
+	xferred = ftdi_write_data(p->fc, p->outbuf, p->outcount);
+
+	if(xferred > 0 && xferred < p->outcount)
+	{
+		int offset = xferred;
+		int remaining = p->outcount - xferred;
+
+		while(remaining)
+		{
+			printf("W\n");
+			if(xferred < 0) return xferred;
+			xferred = ftdi_write_data(p->fc, p->outbuf + offset, remaining);
+            if(xferred < 0)
+            {
+              memmove(p->outbuf, p->outbuf + offset, remaining);
+              p->outcount = remaining;
+              return 0;
+            }
+            offset += xferred;
+			remaining  -= xferred;
+		}
+	};
+	p->outcount = 0;
+
+	return 0;
+}
+
+static int
+ftdi_close( parport_t *parport )
+{
+	ftdi_params_t *p = parport->params;
+
+	if(p->outcount > 0) ftdi_flush_output( p );
+	p->outcount = 0;
+
+	ftdi_usb_close(p->fc);
+	ftdi_deinit(p->fc);
+
+	return 0;
+}
+
+static int
+ftdi_set_data( parport_t *parport, uint8_t data )
+{
+	ftdi_params_t *p = parport->params;
+
+	if(p->autoflush)
+	{
+		if(ftdi_write_data(p->fc, &data, 1) != 1) printf("w\n");
+	}
+	else
+	{
+		p->outbuf[p->outcount++] = data;
+
+		if(p->outcount >= OUTBUF_LEN)
+			return ftdi_flush_output( p );
+	};
+	   
+	return 0;
+}
+
+static int
+ftdi_get_data( parport_t *parport )
+{
+	unsigned char d;
+	ftdi_params_t *p = parport->params;
+
+	while(ftdi_read_data( p->fc, &d, 1) == 0);
+	return d;
+}
+
+static int
+ftdi_get_status( parport_t *parport )
+{
+	return 0;
+}
+
+static int
+ftdi_set_control( parport_t *parport, uint8_t data )
+{
+	ftdi_params_t *p = parport->params;
+
+	p->autoflush = data;
+	if(p->autoflush) ftdi_flush_output( p );
+	
+	return 0;
+}
+
+parport_driver_t ftdi_parport_driver = {
+	"ftdi",
+	ftdi_connect,
+	ftdi_parport_free,
+	ftdi_open,
+	ftdi_close,
+	ftdi_set_data,
+	ftdi_get_data,
+	ftdi_get_status,
+	ftdi_set_control
+};
+
+#endif /* HAVE_LIBFTDI */
Index: src/tap/parport.c
===================================================================
--- src/tap/parport.c	(.../vendor/openwince)	(Revision 135)
+++ src/tap/parport.c	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -32,7 +32,11 @@
 #ifdef HAVE_LINUX_PPDEV_H
 extern parport_driver_t ppdev_parport_driver;
 #endif /* HAVE_LINUX_PPDEV_H */
+#ifdef HAVE_LIBFTDI
+extern parport_driver_t ftdi_parport_driver;
+#endif /* HAVE_LIBFTDI */
 
+
 parport_driver_t *parport_drivers[] = {
 #if defined(HAVE_IOPERM) || defined(HAVE_I386_SET_IOPERM)
 	&direct_parport_driver,
@@ -40,6 +44,9 @@
 #ifdef HAVE_LINUX_PPDEV_H
 	&ppdev_parport_driver,
 #endif /* HAVE_LINUX_PPDEV_H */
+#ifdef HAVE_LIBFTDI
+	&ftdi_parport_driver,
+#endif /* HAVE_LIBFTDI */
 	NULL				/* last must be NULL */
 };
 
@@ -78,3 +85,4 @@
 {
 	return port->driver->set_control( port, data );
 }
+
Index: src/tap/Makefile.am
===================================================================
--- src/tap/Makefile.am	(.../vendor/openwince)	(Revision 135)
+++ src/tap/Makefile.am	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -33,11 +33,13 @@
 	parport.c \
 	parport/direct.c \
 	parport/ppdev.c \
+	parport/ftdi.c \
 	cable.c \
 	cable/generic.h \
 	cable/generic.c \
 	cable/arcom.c \
 	cable/byteblaster.c \
+	cable/usbblaster.c \
 	cable/dlc5.c \
 	cable/ea253.c \
 	cable/ei012.c \
Index: configure.ac
===================================================================
--- configure.ac	(.../vendor/openwince)	(Revision 135)
+++ configure.ac	(.../branches/openwince-usb_jtag)	(Revision 135)
@@ -95,6 +95,18 @@
 
 VL_LIB_READLINE
 
+dnl check for libftdi-config
+AC_PATH_PROG(HAVELIBFTDI, libftdi-config, $PATH)
+if test ! -z "$HAVELIBFTDI"; then
+dnl   LIBFTDI_CFLAGS=`$HAVELIBFTDI --cflags`
+   LIBFTDI_LIBS=`$HAVELIBFTDI --libs`
+   CFLAGS="$CFLAGS $LIBFTDI_CFLAGS"
+   LIBS="$LIBS $LIBFTDI_LIBS"
+   AC_DEFINE(HAVE_LIBFTDI, 1, [Define if you have libftdi])
+else
+   AC_MSG_ERROR([*** libftdi-config not found. You need a working libftdi installation.])
+fi
+
 CFLAGS="$CFLAGS -Wall"
 CPPFLAGS="$CPPFLAGS -I\$(top_srcdir) -I\$(top_srcdir)/include"
 
